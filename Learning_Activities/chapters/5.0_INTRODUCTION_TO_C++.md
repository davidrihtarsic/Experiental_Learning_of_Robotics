---
published: false
---

# INTRODUCTION TO C++

Programming is the process of creating a set of instructions that a computer can follow to perform specific tasks. It involves writing code using a programming language that allows humans to communicate with machines. Programming is the foundation for developing software applications that power everything from smartphones and computers to robots and the internet.

In robotics, programming is essential because it enables us to control how robots behave. By programming a robot, we can dictate its actions, responses to inputs, and interactions with the environment. This is crucial for tasks ranging from simple automation to complex problem-solving and artificial intelligence.

Programming is composed of several fundamental building blocks:

1. **Data**: At the core of programming are data elements, such as numbers, text, and other values, that we manipulate with our code. Data is used to represent information and track the state of our program.

2. **Operations**: These are actions performed on data. They include mathematical calculations, comparisons, and more. By applying operations, we can transform and process data to reach desired outcomes.

   ```cpp
   int sum = 5 + 3;  // An example of an arithmetic operation
   ```

3. **Selection (Conditionals)**: These are used to make decisions within a program. By using conditional statements, like `if-else`, the program can choose between different paths based on specific conditions.

   ```cpp
   if (temperature > 30) {
       // If temperature is greater than 30, perform this action
   } else {
       // Otherwise, perform a different action
   }
   ```

4. **Repetition (Loops)**: Repetition allows programs to perform tasks multiple times. Loops, such as `for` and `while` loops, let us execute a block of code repeatedly until a certain condition is met.

   ```cpp
   for (int i = 0; i < 5; i++) {
       // Repeat this block 5 times
   }
   ```

These basic concepts are the building blocks of programming and allow us to create sophisticated and efficient programs for various applications, including robotics. With programming, we can harness the power of computers to solve problems and automate processes in innovative ways.

---

C++ is a high-performance programming language that is widely used for building software applications. It was developed by Bjarne Stroustrup in 1979 as an extension of the C programming language. C++ is an object-oriented language, which means that it provides features for organizing and modularizing code in the form of "objects." C++ is also a compiled language, which means that the source code is converted into machine code by a compiler before it can be run on a computer.

Here are some basic concepts in C++:

**Variables**: A variable is a named location in memory that stores a value. In C++, you must specify the data type of a variable when you declare it. For example:

```cpp
int x;      // declares a variable x of type int
float y;    // declares a variable y of type float
char c;     // declares a variable c of type char
```

**Operators**: Operators are special symbols that perform specific operations on one or more operands. C++ has a variety of operators, including arithmetic operators (e.g., +, -, *, /), comparison operators \(e.g., ==, !=, \>, \<\), and logical operators \(e.g., &&, \|\|, \!\).

**Control structures**: Control structures are statements that control the flow of execution in a program. C++ has several types of control structures, including if statements, for loops, and while loops.

**Functions**: A function is a block of code that performs a specific task. C++ has a large standard library of functions, and you can also define your own functions. A function definition has the following syntax:

```cpp
return_type function_name(parameter list) {
   // function body
}
```

**Object-oriented programming**: As I mentioned earlier, C++ is an object-oriented language, which means that it provides features for organizing and modularizing code in the form of "objects." An object is a self-contained unit of code that represents a real-world entity, such as a person, a car, or a bank account. Objects have attributes (data) and behaviors (functions). In C++, you can define classes to create objects.



 Exception handling
--------------------------------------------------------------------------------



 Input and output
--------------------------------------------------------------------------------



 Debugging and testing
--------------------------------------------------------------------------------



 Advanced topics threading memory management templates
--------------------------------------------------------------------------------

### Bit-field variable type

Variable bit fields are a specific type of data structure in C++ that allows a user to store multiple bit-sized values within a single variable. This can be useful for storing several different values in the same memory space or for compressing data. An example of a variable bit field in C++ is shown below:

```c++
struct example {
 unsigned int value1 : 4; // Use 4 bits
 unsigned int value2 : 8; // Use 8 bits
 unsigned int value3 : 12; // Use 12 bits
} myStruct;
```

In this example, we have defined a structure called 'example' which contains three members - 'value1', 'value2', and 'value3'. Each of these members has been defined as a variable bit field using the 'unsigned int' data type and the ':' syntax, which allows us to specify the number of bits that each member should use. In this case, 'value1' will use 4 bits, 'value2' will use 8 bits, and 'value3' will use 12 bits. To access these values, we can use the members of the structure, for example, 'myStruct.value2'.

```c++
struct adc4 {
  unsigned int value1 : 10;
  unsigned int value2 : 10;
  unsigned int value3 : 10;
  unsigned int value4 : 10;
};

unsigned int adc_val[40];           //40 values
adc4 myAdc[10];                     //40 values

void setup() {
  Serial.begin(9600);
  Serial.println(sizeof(adc_val));  //print 80
  Serial.println(sizeof(myAdc));    //print 50
}

void loop() {

}
```


 Basic syntax and structure of a C++
--------------------------------------------------------------------------------

A C++ program begins with preprocessor directives, an example of which is including header files. Preprocessor directives provide instructions to the compiler and tell it what additional files to include in the compilation process.

Following the preprocessor directives are declarations, which include variables, constants, and user-defined functions.

The main function is the entry point of any C++ program, and contains all of the program’s executable code. Within the main function are more definitions, which are additional declarations of data types, variables, constants, and user-defined functions. Finally, the program is concluded with the return 0 statement, indicating success.

Developing a C++ program requires careful attention to the order in which the preprocessor directives, declarations, main function, and definitions are written. Only by understanding the basic structure of a C++ program can a programmer write effective, efficient, and bug-free code.

Here is an example of a basic C++ program that blinks LED on a 13-th pin of an Arduino Uno controller and can be written in Arguing IDE:

```c++
#include <avr/io.h>
#include <util/delay.h>
int time_ms = 1000;     // Variable declaration
void setup();           // Function declaration
void loop();

int main() 
{
    setup();            // Function call
    while (true){       // Main LOOP
        loop();
    }
    return 0;
}
void setup() {          // Function definition
    PDDB |= (1<<PINB5);
}
void loop(){
    PORTB |= (1<<PINB5);
    _delay_ms(time_ms);
    PORTB &= !(1<<PINB5);
    _delay_ms(time_ms);
}
```
: Native C++ program for ATmega328. {#lst:native_cpp}

Programming an Arduino Uno board in native C++ is much more difficult than in Arduino IDE. Arduino IDE makes it easier for users to write and debug code without having to know the details of the underlying hardware. In addition, the IDE provides many additional functions which simplify the usage of additional peripherals and actuators such as serial communication, LCDs, servo motors, step motors... This is especially true and important for beginners.


### Task 1: Writing a Basic C++ Program for Arduino (Without Arduino IDE Functions)
To better understand the fundamentals of C++ before using Arduino-specific functions, write a simple C++ program that runs on an Arduino board but does **not** rely on `setup()` and `loop()`. The program should:

- Blink an LED connected to **pin 13** of an Arduino Uno.
- Use **direct register manipulation** instead of `digitalWrite()`.
- Implement a **main function** as in standard C++ programs.

**Modify and complete the following template:**

```c++
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB |= (1 << PINB5); // Set pin 13 as output

    while (true) {
        PORTB |= (1 << PINB5);  // Turn LED on
        _delay_ms(500);
        PORTB &= ~(1 << PINB5); // Turn LED off
        _delay_ms(500);
    }

    return 0;
}
```
### Questions to consider:
- Why does this program use `DDRB`, `PORTB`, and `PINB5` instead of `pinMode()` and `digitalWrite()`?  
- How does the `while(true)` loop function compared to `loop()` in Arduino IDE?  
- What happens if the `return 0;` line is removed?  

---

### Task 2: Analyzing the Structure of a Native C++ Arduino Program
Use the provided **native C++ code for Arduino** (from the learning material) and identify the following elements **by line number**:  

- Preprocessor Directive (`#include` statement)  
- Variable Declaration  
- Function Declaration  
- Function Definition  
- Function Call  
- Main Function  
- Comment  

By completing these tasks, you will gain a deeper understanding of **how C++ works independently of Arduino's simplified environment**, giving you a solid foundation for more advanced programming.

### Summary:
#### <++>

### Issues:
#### Not including a semicolon at the end of each statement:
Every statement in C++ must end with a semicolon. If a semicolon is omitted, the code will not compile correctly.

#### Not properly formatting the code:
Properly indenting and spacing code is important in C++ to make the code easier to read. Not formatting the code correctly can lead to syntactical errors.

#### Not using correct capitalization:
C++ is a case sensitive language and therefore proper capitalization is important. If the wrong capitalization is used, it can lead to syntax errors.



## Writing clean code

The Arduino IDE (Integrated Development Environment) has contributed to clean and readable code by promoting a simple and structured coding approach. One of the ways it achieves this is by introducing the `setup` and `loop` functions.

The \"setup\" function is called only once when the Arduino board starts up. It is typically used for initializing variables, setting pin modes, and configuring any necessary settings. By separating this initialization code into a designated function, it becomes easier to identify and understand the setup process, making the code more organized and readable.

The \"loop\" function is called repeatedly after the setup function. This function contains the main logic of the program, where actions are performed continuously. By having a dedicated loop function, it enhances the readability of the code as it clarifies the flow of execution.

The Arduino IDE enforces the presence of these two functions, which serves as a guideline for developers to structure their code. This standardization promotes cleaner code because it encourages encapsulating specific functionalities in separate functions. This helps to compartmentalize different tasks and improves code modularity and maintainability.

Additionally, the Arduino IDE provides various built-in libraries and functions that simplify common tasks, such as reading sensor values or controlling actuators. These libraries follow consistent naming conventions and provide well-documented APIs, making it easier for developers to understand and use them. By leveraging these libraries, developers can write cleaner and more readable code, as they can focus on the high-level functionality and rely on the underlying library for the low-level details.

In order to make your code readable you have to clean your code regularly. This step is very important to not to slow down the programming process in the future programming.
You will probably spent the same amount of time cleaning the code that you needed for writing a working version.

In general you can follow some rules:

1. Use FUNCTIONS for every single action,
2. COMMENT the code only where is necessary,
3. Use EXPLANATORY CONSTANTS and VARIABLES

to make your code clean.

Our aim is to write more readable code like in [@lst:052_Writing_Clean_Code]:


```cpp
#include "RobotMoves.h"
void setup()
{
  setIOpins();
  moveForward();
  delay(3000);
  stopTheRobot();
}

void loop()
{

}
```
: Writing Clean Code. {#lst:052_Writing_Clean_Code}

... we will do it in several steps.

### Tasks:

1. Write programming functions for moving the robot in several dirrections:
    1. `moveForward()`,
    2. `moveLeft()`,
    3. `moveRight()`,
    4. `moveBackward()`,
    5. `stopTheRobot()`.

2. Save all the functions into header file:
  `RobotMoves.h`. An example of header file is shown in [@lst:RobotMoves]


```cpp
/****************************
 * IO pins of the Robot
 ***************************/
const int LEFT_MOTOR_PIN_1  = 7;
const int LEFT_MOTOR_PIN_2  = 6;
const int RIGHT_MOTOR_PIN_2 = 5;
const int RIGHT_MOTOR_PIN_1 = 4;
/****************************
 * Function declarations
 ***************************/
void setIOpins();
void moveForward();
/****************************
 * Function definitions
 ***************************/
void setIOpins(){
  pinMode( LEFT_MOTOR_PIN_1, OUTPUT);
  pinMode( LEFT_MOTOR_PIN_2, OUTPUT);
  pinMode(RIGHT_MOTOR_PIN_1, OUTPUT);
  pinMode(RIGHT_MOTOR_PIN_2, OUTPUT);
}
void moveForward(){
  digitalWrite( LEFT_MOTOR_PIN_1, LOW);
  digitalWrite( LEFT_MOTOR_PIN_2, HIGH);
  digitalWrite(RIGHT_MOTOR_PIN_1, LOW);
  digitalWrite(RIGHT_MOTOR_PIN_2, HIGH);
}
```
: Robot Moves. {#lst:RobotMoves}

### Questions:

1. Explain why functions contribute to more readable code.
2. Why is good to use explanatory variables?
3. <++>

### CLEAN CODE EXPLAINED

#### Comments - YES and NO

Comments are very helpful and necessary. Keep them short and meaningful whenever is needed. May also help during thinking process while beginning designing the code.

```cpp
// robot will go forward
digitalWrite(7,HIGH);
digitalWrite(6,LOW);
digitalWrite(5,HIGH);
digitalWrite(4,LOW);
```

Don't use comments where the code is self-explanatory, for example:

```cpp
  delay(3000); //wait for 3000ms
```

#### Functions

Concatenate programming code into meaningful functions is a must! Previous example of code for `driving a robot forward` is very difficult to understand at first sight. We can make cleaner code as is shown in nex example where is easier to understand what-is-what:

```cpp
void robotForward()
{
  digitalWrite(LEFT_MOTOR_PIN_1,HIGH);
  digitalWrite(LEFT_MOTOR_PIN_2,LOW);
  digitalWrite(RIGHT_MOTOR_PIN_1,HIGH);
  digitalWrite(RIGHT_MOTOR_PIN_2,LOW);
}
```
Compact code is more understandable than large one, see next example:

```cpp
void setup()
{
  setIOpins();
  moveForward();
  delay(3000);
  robotStop();
}
```

##### Function declaration

Function declaration is highly advisable since allow you a quick overview of available functions in a current file. It is like a table of functions with it's return type and parameters. All declarations are tipically found at the beginig of the file.

```cpp
void moveForward();
void moveLeft();
void moveLeft_PWM(int pwm_value);
```

##### Function Definition

A function definition provides the actual body of the function.

```cpp
void robotForward()
{
  digitalWrite(LEFT_MOTOR_PIN_1,HIGH);
  digitalWrite(LEFT_MOTOR_PIN_2,LOW);
  digitalWrite(RIGHT_MOTOR_PIN_1,HIGH);
  digitalWrite(RIGHT_MOTOR_PIN_2,LOW);
}
```

#### Constants

Use explanatory constants to more clearly represent unintuitive numbers or other abstract values. Use these constants instead of comments since these numbers will appear several times during programming code.

```cpp
const int LEFT_MOTOR_PIN_1 = 7;
const int LEFT_MOTOR_PIN_2 = 6;
```

Now you can easily see why the pins are set as OUTPUT. Because there is `Left motor` attached.

```cpp
void setIOpins()
{
  pinMode(LEFT_MOTOR_PIN_1, OUTPUT);
  pinMode(LEFT_MOTOR_PIN_2, OUTPUT);
}
```

#### Variables

Use explanatory variables to make if-statements easily readable and thus understandable. Make `boolean` variables as short statements with no inverting logic.

For example we will use the case where the robot should stop as soon it hits the obstacle with front bumper. The worst case scenario of the program could look like this (we have all done it at some point):

```cpp
void loop()
{
  if (digitalRead(A0) == FALSE){
    digitalWrite(7, HIGH);
    digitalWrite(6, LOW);
    digitalWrite(5, HIGH);
    digitalWrite(4, LOW);
  }else{
    digitalWrite(7, LOW);
    digitalWrite(6, LOW);
    digitalWrite(5, LOW);
    digitalWrite(4, LOW);
  }
}
```

And more clean representation of same functionality is shown in next example of the code. Line 3 is easy readable, simple, clear and easy understandable.

```cpp
void loop()
{
    int front_bumper_is_pressed = digitalRead(BUMPER_INPUT);
    if (front_bumper_is_pressed) robotStop(); else robotForward();
}
```

#### Header files

To keep our main program file short and transparent as possible we can put supporting code (e.g. functions, settings, ...) into separate file and include it at the beginning of the main program. These files are called header files. We can write a function and save it into header file called "calculate.h"

```cpp
int sumTwoNumbers(int A, int B)
{
  return A+B;
}
```

In our main program we can include the header file and use the function:

```cpp
#include "calculate.h"

int main()
{
  int a = 5, b = 3;
  int sum = sumTwoNumbers(a, b);
}
```

There are several reasons to use header files in C++:

**Code organization**: Header files allow you to organize your code into logical units, which can make it easier to understand and maintain. For example, you can use a header file to group together related function declarations, constants, and data types.

**Code reuse**: Header files can be included in multiple source files, which allows you to reuse the same code in multiple places without having to copy and paste it. This can save time and reduce the risk of errors.

**Compilation speed**: When you include a header file in a source file, the compiler does not need to recompile the code in the header file every time it compiles the source file. This can significantly improve the compilation speed of your program, especially if the header file contains a large amount of code.

**Separation of interface and implementation**: Header files can be used to separate the interface (the function declarations and data types that are visible to the rest of the program) from the implementation (the actual code that performs the tasks). This can make it easier to change the implementation of a module without affecting the rest of the program.

#### Pre-process

The preprocessors are the directives, which give instructions to the compiler to pre-process the information before actual compilation starts (e.g. `#include` is one of them). You can easily use as such text substitutions for more clear code reading.

```cpp
#define LEFT_MOTOR_PIN_1 7
#define LEFT_MOTOR_PIN_2 6
```

Remember! `#define` is really a simple text substitution and is not type-safe. Furthermore, we have to be certain that our definition will not interfere with other code used outside of our scope e.g. `libraries`. The last example is not the best representation of `#define` usage. In these case the `const int` is more proper way to go (allowed type checking, debugging). But `#define` has other benefits where `const` can not be used.

##### Translations

The substitutions can be used as a translation and simplification of code. Such code can be introduced to very young children to get involved in programming.

```cpp
#define vkljuci_led digitalWrite(13,HIGH)
#define izkljuci_led digitalWrite(13, LOW)
#define pocakaj(time) delay(time)
void loop(){
  vkljuci_led;
  pocakaj(1000);
  izkljuci_led;
  pocakaj(1000);
}
```

##### Debugging

You can even substitute function names e.g. `debug(txt)` with `Serial.println(txt)` and easily separate debugging code lines from necessary serial print of data. 

```cpp
#define debug(txt) Serial.porintln(txt)
void setup()
{
  Serial.begin(9600);
  debug("Running...")
}
void loop()
{
  unsigned long myTime = millis();
  Serial.println(myTime);
  delay(1000);
}
```

When we are done with programming and debugging is not needed anymore we can simply change `#define` line to nothing:

```cpp
#define debug(txt) 
```

And these programming sentences will not be used. More sophisticated example is shown where programmer can switch between debugging mode (with `#define DBG 1`) and normal operation (with `#define DBG 0`) where code statement `debug("Running...")` will not even compile into program.

```cpp
#define DBG 1
#if DBG == 1
#define debug(txt) Serial.porintln(txt)
#else
#define debug(txt)  
#endif
void setup()
{
  Serial.begin(9600);
  debug("Running...")
}
```

### Summary:

### Issues:
#### What is the difference between `const int` and #define?
`#define` is textual replacement, so it is as fast as it can get. Also it can save some RAM. The downside is that it's not type-safe.

`const` variables may or may not be replaced inline in the code. It is guaranteed to be type-safe though since it carries its own type with it.

<!--
note: to je še v slovenščini, kako pisati pregledno kodo... zapiski od
    Uncle Boba
    nekaj sem že vključil... potrebno bi bilo omeniti še kaj...
    to-do

### PROGRAMMING CODE EXPLAINED

1. Zaporedje
2. Izbira
3. Ponavljanje

#### Kako pisati pregledno kodo programa?

- [Clean CODE](https://www.youtube.com/watch?v=7EmboKQH8lM)

Proces pisanja kode je izredno NE-linearen, naše misli skačejo na različne težave in različne potrebe, ki se utegnejo pripetiti med programiranjem. Zato ni čudno, da bo prva delujoča koda zapletena in raztresena. Zato jo moramo po končnem testiranju NUJNO urediti.

    Ko napišete delujočo kodo in ste jo stestirali, ste na pol-poti. Potrebno jo je še urediti in narediti berljivo! (Uncle Bob)

Organizacija programa naj bo podobna pisanju članka v časopisu:  
1. Začnemo z naslovom, nato
2. napišete povzetek
3. nato sledijo odstavki, ki razkrivajo zgodbo v podrobnosti in 
4. na koncu je zaključek z rezultati.

Taka ureditev omogoča bralcu, da besedilo lahko zapusti takoj, ko vsaj približno razume namen vsebine. Zamislite si, da berete časopis z novicami, a preberete le tiste, ki vas zanimajo, ostale pa le preletite.

#### Manj je več

Krajše koščke programa je lažje razumeti. Zato se moramo potruditi, da vsako zaključeno celoto strnimo v podprogram ali funkcijo.

#### Funkcije

Pri funkcijah naj bi se držali nekaj previl:

##### Koda v funkcijah naj bo kratka

Funkcija naj naredi le eno stvar. To pomeni, da iz kode, ki je v funkciji ne moremo izvleči programske stavke in jih logično ločiti v svojo funkcijo. Seveda pa, moramo vse te majhne funkcije primerno poimenovati.

    Imena funkcije naj bodo GLAGOLI in ne samostalniki, ker funkcije OPRAVLJAJO neko nalogo. (Uncle BOB)

##### Oblikovanje funkcij v razrede

Pri oblikovanju funkcij lahko opazimo, da funkcije operirajo s podatki. Če se ti podatki ponavljajo ali pa so podobni moramo razmisliti o uporabi RAZREDA (callses). Naprimer krmiljenje DC motorja je tak primer. Lahko imamo več motorjev in za vsakega posebej želimo nastavljati smer in hitrost. V ta namen bi bilo smiselno pripraviti class:

```cpp
class Motor
{
  public:
    int smer;
    int hitrost;
};
```

#### Da je koda pregledana je verjetno bolj pomembno kot, da deluje... zakaj?

Če imamo delujočo kodo in je ta nepregledna, se lahko zgodi, da ko se bodo zahteve spremenile (posodobili bomo program) bomo skušali kodo popraviti in je ne bomo mogli. Da o možnosti, da bi nam jo popravil nekdo tretji sploh ne razmišljamo.
Če pa je koda pregledna, pa ne deluje nam jo lahko pomaga rešiti bolj izkušenj programer.

Pregledno kodo lahko uporabi nekdo drug in je prenosljiva.

#### Koda naj gre iz višjega nivoja v nižji

Med posameznimi vrsticami naj ne bo velikih prehodov med nivoji programiranja. Naprimer ne mešajmo deklaracij objektov z deklaracijami konstant.

#### Razlagalna spremenljivka

Te spremenljivke določimo zato, da bodo if-stavki bolj berljivi. Samo spremenljivko določimo predhodno in ji damo tako ime, ki nakazuje na neko logično stanje. Izogibamo se negaciji.

```cpp
stikaloJeSklenjeno = digitalRead(3);
if (stikaloJeSklenjeno) digitalWtire(3, HIGH);
```

#### Kakšna so naša pričakovanja glede programske kode?

##### Vmesne različice naj bodo delujoče

Postaviti si moramo kratke roke ob katerih bomo izdali delujočo kodo. Koda je lahko še podhranjena z uporabnimi funkcijami, a vse funkcije morajo delovati. Izdajanje vmesne različice naj vsebuje:
- vse delujoče elemente kode,
- njihovo dokumentacijo in
- koda naj bo urejena ter
- vsak njen del stestiran.

##### Dodajanje novih funkcij v program ne sme upočasniti dela

Dodajanje novih funkcij v program ne sme upočasniti dela, če se to zgodi, je verjetno zaradi tega, ker smo pred tem naredili zmedo v programski kodi. Še en razlog več zakaj **mora** biti koda urejena.

#### Spremembe programske kode morajo biti enostavne

Že iz besedne zveze SOFT-WARE je razvidno, da je to MEHAK - IZDELEK in ga je zato enostavno spremeniti. Zato vsaj majhne spremembe ne smejo biti težava in morajo biti hitro implementirane. K temu koraku pripomore zopet:
- pregledna koda in
- dobro napisan testni program

#### Program naj bo s časom vedno boljši

#### Popravljanje kode brez strahu

Kadar imamo občutek, da bi morali kodo izboljšati, jo dokumentirati ali narediti preglednejšo - imamo verjetno prav. Vendar se tega dela lahko ustrašimo, češ, da bomo kodo morda uničili. Tega se ne smemo nikoli ustrašiti! V veliko pomoč nam je lahko dober testni algoritem kode. Tako brez težav počasi spreminjamo kodo in jo sproti testiramo. Tak proces je zanesljiv in enostaven.

#### Seznanjanje svojega sodelavca s kodo

Pametno je seznanjanje svojih sodelavcev z vašim delom (programiranjem) zato, da vas lahko nadomestijo, če ste vi odsotni z dela. Poleg tega pa je to dobra praksa pregleda kode in tako pogosto kodo izboljšamo z idejami sodelavcev.

#### Testiranje kode

1. Ne napiši kode dokler nisi napisal testa zanjo in je le-ta spodletel, ker koda ne obstaja
2. Ne napiši daljšega testa kode, le toliko, da je dovolj, da spodleti.
3. Na napiši daljše kode, le toliko, da popraviš spodleteli test.

#### Arhitektura kode

Iz arhutekture kode mora biti jasno za kakšen projekt gre. Podobno kot lahko iz tlorisa stavbe lahko povemo za kater namen je zgrajena. Enako je, če pogledamo kako je urejena arhitektura računalniške matične plošče.

Ker gre pri robotiki v najosnovnejšem primeru za S-R-A loop bi verjetno bilo primerno, da je tudi arhitektura kode taka.
-->


## Testing programming code

Testing code in Arduino is important because it helps to ensure that the code is working correctly and producing the desired results. Testing can help to catch bugs and errors in the code, and can also help to verify that the code is performing the tasks that it is intended to perform. By thoroughly testing code, you can improve the reliability and functionality of your Arduino projects.

The `Serial.println()` function is a useful tool for debugging Arduino code because it allows you to print information to the serial monitor, which can help you understand what your code is doing and troubleshoot any problems.

To use `Serial.println()` for debugging, you will need to include the Serial library at the top of your sketch and initialize the serial monitor using the `Serial.begin()` function. Then, you can use Serial.println() to print strings or variables to the serial monitor.

Here is an example of how to use `Serial.println()` for debugging in an Arduino sketch:


```cpp
#include <RobotMovingFunctions.h>
//include <RobDuinoSerialTesting.h>

void setup()
{
  Serial.begin(115200);

  Serial.print("Setting IO pins .."); // Reporting start of function.
  setIOpins();                        // Function execution.
  Serial.println("..DONE");           // Reporting end of function.

  moveForward();
  delay(3000);
  stopTheRobot();
  
}

void loop() { }

```
: Testing programming code. {#lst:053_Testing_programming_code}

To view the output of the Serial.println() statements, you will need to open the serial monitor in the Arduino IDE. You can do this by clicking on the "magnifying glass" icon in the top right corner of the window.

### RobDuino Testing Mode

Since testing programming code and hardware is one of the key features in designing a robot it is recommended that testing functions are a part of your main program. 

In further lectures we will be using more advances `Testing mode` where single digital outputs can be controlled; and inputs will be measured in digital and analog manner. This testing process is available if you have installed `RobDuino Library` (see Program Installing chapter). The testing mode will be trigged by the command `testing`. The output will show every output state:

```cpp
******* Testing mode ********************
Dig. Out	Dig. In.	An.In.
D0 = 1		A0 = 0		A0 = 293
D1 = 0		A1 = 0		A1 = 334
D2 = 0		A2 = 0		A2 = 353
D3 = 0		A3 = 0		A3 = 369
D4 = 0		A4 = 0		A4 = 339
D5 = 0		A5 = 0		A5 = 264
D6 = 0
D7 = 0
-------------------------------------------
```

> ### Task: RobDuino module testing
>
> 3. Uncomment line 2 in [@lst:053_Testing_programming_code]:  
> `#include <RobDuinoSerialTesting.h>
> 4. Explore testing functions with command `testing` writing it into Serial Monitor and you will get this respond:

```cpp
*** Testing mode - menu - ******************
*    help - prints this text menu
*    D5   - toggles output state of D5
*    Dx   - toggles output state of any Dx,
*           x is any num. from 0 .. 13.
*    run  - toggles monitoring od I/O pins
*    exit - exits the Testing mode.
*-------------------------------------------
Type any command to continue ...
```

> ### Questions: 
>
> 1. Explain why testing is important.
> 2. Describe the techniques of testing.
> 3. What parts of the robot should be tested regularly.

### Summary:
#### Testing mode

### Issues:
#### How can I get RobDuinoSerialTesting working.

Basically you need to do these steps:

1. install RobDuino Library
2. put this code at the top of your porgram:  
      `#include <RobDuinoSerialTesting.h>`
3. Compile and write the porgram to your Arduino UNO controller
4. Open `Serial Monitor` window
5. and write `testing` command into prompt.




 Flow control
--------------------------------------------------------------------------------
Flow control in C++ programming is the mechanism that allows the execution path of a program to change based on conditions, loops, or jumps. It is fundamental to creating dynamic and responsive programs. The primary ways to control flow in C++ include:

- **Jump Statements**: Facilitate the control flow by jumping to other parts of the program. The break, continue, and goto statements are examples of jump statements.
- **Loop Statements**: Enable executing a block of code repeatedly as long as a condition remains true. C++ offers for, while, and do-while loops for this purpose.
- **Conditional Statements**: Direct the program flow based on boolean conditions. Examples include if, if-else, and switch statements.

The `goto` statement in C++ provides a way to jump to another part of the program, altering the normal sequential flow of execution. It's generally recommended to use goto sparingly, as it can make code harder to read and maintain, but it can be useful in certain contexts, such as breaking out of deeply nested loops.

### Tasks:

1. Mark the moving instructions with the label `repeating_moves:`.
2. At the end of the moves put the `goto` statement and jump to repeating_moves label.

```cpp
#include <RobotMovingFunctions.h>

void setup()
{
  setIOpins();

repeating_moves:
  moveForeward();
  delay(1000);
  moveLeft();
  delay(550);
  robotStop();
  delay(1000);
goto repeating_moves;

}

void loop()
{

}
```
: Flow control with goto statement. {#lst:054_Flow_Control}

### Questions:

1. Why is using goto statement not the best programming practice.
2. Which form two is programming instruction: a) repeating_moves or b) goto repeating_moves, and `;` is needed?

### Summary:

The goto statement in C++ programming is a control flow instruction that allows the program to jump to another point in the code. It is used to transfer control to a labeled statement within the same function. Despite its capability to alter the execution flow in a very straightforward manner, goto is often discouraged in modern programming practices due to several reasons:

- **Readability**: Frequent use of goto can make code difficult to read and understand. It breaks the structured programming paradigm, making the flow of execution non-linear and less predictable.
- **Maintainability**: Programs that rely on goto statements can be harder to maintain and debug. The non-linear flow can introduce bugs that are difficult to trace and fix.
- **Alternative Constructs**: C++ provides structured control flow constructs such as loops (for, while, do-while) and conditionals (if, else if, else, switch) that can handle nearly all the use cases for goto in a cleaner, more structured way.

However, there are specific situations where goto might be considered useful or necessary, such as:

- **Breaking out of nested loops**: When a break is needed from deeply nested loops, a goto statement can provide a straightforward solution without having to refactor large portions of code.
- **Error handling**: In some low-level programming scenarios, especially in system-level programming, goto can be used for cleanup tasks and to jump to error handling routines.

Despite these use cases, it's important to approach goto with caution. Its use should be limited to scenarios where the benefits outweigh the potential drawbacks in terms of code clarity and maintainability. Modern C++ programming encourages structured programming practices, with goto largely being considered a relic of earlier programming styles.

### Issues:

#### *<++>*

<++>



## Programming loops

It is very often needed, that we want to repeat some part of code several times. In that case we can use programming loops where we can specify which code should be repeated. In general there are two very often situation where we are using the programming loops:

1. We know `how many times` some code should repeat and
2. The code is `repeated while the condition` is met.

### For-Next Loop

So called `For-Next` loop is used whenever the repetition of the code can be controlled by a `counter`. Counter is a number with some **starting value** and gets incremented by each repetition of the code. When `counter` reaches the given **ending value** repetition will stop. Typical examples where `For-Next` loop is used are:

- filling an array of data,
- summarising of all the costs in the bill
- robot should turn for **8 times** with 45 degree step to complete full rotation.

### While Loop

`While` loop is used in situations where we can not predict the numbers of repetitions in advanced. In this case we must state the `condition` that must be met to repeat the code. The repetition of the code will be terminated when the `condition` will not hold anymore. Typical examples are:

- read the content to end of file,
- divide some number by 2 while we can,
- while no obstacle is in front of the robot it should drive forward

### Do-While Loop

The Do-While loop in C++ programming is a control flow statement that executes a block of code at least once and then either repeatedly or until a particular condition is met. The condition is evaluated after the execution of the block of code. If the condition is true, the block of code is executed again. This repeats until the condition becomes false. 

Here are three examples where a do-while loop can be suitable in programming a mobile robot:

- Navigating a Maze: A do-while loop can be used to control a robot to navigate through a maze by repeating movements (forward, turn left or right) until it finds the exit. 
- Obstacle Avoidance: A do-while loop can be used to program a robot to continuously move in a particular direction until it detects an obstacle, then it changes direction.
- Searching for a Specific Object: A robot can be programmed using a do-while loop to keep searching in an environment until a particular object is found. This can be useful in search and rescue missions, or in a manufacturing setting where a robot is used to find and retrieve specific items.

### Task: FOR-NEXT LOOP

1. For example the next [@lst:240_Programming_Loops] repeats the functions **robotLeft()** and **robotRight()** for **10 times** and robot will do a funny \"dancing\" move.

```cpp
#include <RobotMovingFunctions.h>

void setup()
{
  setIOpins();
  // Repeating Left and Right movement
  // for 10 times to make a danging move
  for (int i = 0; i < 10; i++)
  {
    robotLeft();
    delay(100);
    robotRight();
    delay(100);
  }
  stopTheRobot();
}

void loop()
{

}
```
: Programming Loops. {#lst:240_Programming_Loops}

2. Experiment a bit more with such programming techniques and change some code:
    - value of `i`,
    - duration of `delay()` function,
    - add some other functions to the `for-next` loop...

### Task: WHILE LOOP

3. Change the `for-next` loop with this `while` loop. Can you predict the result?

```cpp
while ( 1 == 1 ){
    robotLeft();
    delay(100);
    robotRight();
    delay(100);
}
```

Presented `while` loop is not an useful example as the condition `( 1 == 1 )` will never change and will be always `true`. So, we created an infinite loop. `While` loop is far more usable if in the condition is some sensor's value, as we will see in next sections.

### Questions:

1. Name the situation  where `for-next` loop can be used.
2. What is the purpose of a `counter` in `for-next` loop?
3. What is the difference between `for-next` and `while` loops?

### Summary:

Loops in C++ programming are used for flow control, allowing developers to execute a block of code repeatedly until a certain condition is met. There are three types of loops:
- for,
- while, and
- do-while.

The `for` loop is typically used when the number of iterations is known. It contains an initializer, a condition, and an iterator.
The `while` loop executes a block of code as long as the condition remains true. Unlike the `for` loop, the number of iterations in a `while` loop is indeterminate and depends on when the condition becomes false.
The `do-while` loop is similar to the `while` loop but executes the block of code at least once before checking the condition. Loops are fundamental for flow control in C++, allowing for efficient and organized code execution.

#### For Loop:

Executes a block of code a specific number of times.

```cpp
for (initialization; condition; increment) {
    // Code to execute
}
```

#### While Loop

Executes a block of code as long as a condition remains true.

```cpp
while (condition) {
    // Code to execute
}
```

#### Do-While Loop

Similar to the while loop, but it executes the block of code at least once before checking the condition.

```cpp
do {
    // Code to execute
} while (condition);
```

<++>

### Issues:

#### *Can I measure the execution time of the loop?*

Yes, you can. You must save the time before the loop and save the time after the loop is executed. The difference in these two values is the spent in the execution of the loop. A minimal working example counld look like this:
```cpp
unsigned long start_time = millis();
for (int i = 0; i<100; i++)
{
  //some code in this loop
}
unsigned long stop_time = millis();
unsigned long loop_duration = stop_time - start_time;
```

#### *Can I exit a while loop.*

Yes, you can use the "break" statement to exit a while loop in C++. However, this is not a common practice it is advised to set appropriate condition to exit a while loop.
Here is an example of using "brake" statement:

```cpp
int x = 0;
while (x < 10) {
  Serial.println(x);
  x++;
  if (x == 5) {
    break;
  }
}
```

This code will output the following to the serial port:

```
0
1
2
3
4
```

In this example, the "break" statement is used to exit the while loop when the value of "x" becomes 5. As a result, the loop only executes 5 times, rather than 10 times.

It is also possible to use the "continue" statement to skip the remainder of the current iteration of a loop, without exiting the loop entirely. For example:

```cpp
int x = 0;
while (x < 10) {
  x++;
  if (x % 2 == 1) {
    continue;
  }
  Serial.println(x);
}
```

This code will output the following to the serial port:

```
2
4
6
8
10
```

In this example, the "continue" statement is used to skip the remainder of the current iteration of the loop if the value of "x" is odd. As a result, only the even values of "x" are printed.



## Variables and data types

In earlier examples we have stored some values into `variables` (e.g counting `for loop` repetition). Variables are the containers for storing data values usually located in RAM (also in EPROM, FLASH ...). In order to store different data (e.g. numbers, words ...) we have to use different type of variables. The declaration of the variable ( =creation ) has next syntax:

```cpp
type varialble_name = value;
```

With next example we will solve the problem how to make light blinking while the robot is driving in reverse.

### Task: USING VARIABLES

1. Start with this example of driving the robot for 3s forward and then for 3s backward. Test program example in [@lst:250_Variables_and_Data_Types]. Then try to add some code to blink the light while the robot is driving backward.

```cpp
#include <RobotMovingFunctions.h>
void setup()
{
  setIOpins();

  moveForward();
  delay(3000);
  moveBack();
  deay(3000);
  stopTheRobot();
}
void loop()
{
}
```
: Variables and Data Types. {#lst:250_Variables_and_Data_Types}

2. As you probably find out you have to divide the duration of 3000 ms into smaller durations and meanwhile controlling the light output. This can be done with`for-next` loop which repeats 10 times.

    Change the $9^{th}$ line `delay(3000)` in previous example into `for-next` loop with 10 repetition, but with the same overall duration of 3000 ms.

```cpp
...
moveBack();
for (int i = 0; i < 10; i++)
{
  delay(150);
  delay(150);
}
stopTheRobot();
...
```

3. Add some code for blinking the LED in the `for loop` during the robot is driving backward.

    > Don't forget to set the REVERSE_LIGHT_PIN value and its `pinMode(...)`.

```cpp
...
moveBack();
for (int i = 0; i < 10; i++)
{
  digitalWrite(REVERSE_LIGHT_PIN, HIGH);
  delay(150);
  digitalWrite(REVERSE_LIGHT_PIN, LOW);
  delay(150);
}
stopTheRobot();
...
```

4. More advanced way to do a time conditioned loop is shown in next example:

```cpp
...
robotBack();
unsigned long start_time = millis();
int time_diff = 0;
while (time_diff < 3000)
{
  digitalWrite(REVERSE_LIGHT_PIN,HIGH);
  delay(150);
  digitalWrite(REVERSE_LIGHT_PIN,LOW);
  delay(150);
  unsigned long now = millis();
  time_diff = now - start_time;
}
stopTheRobot();
```

### Questions:

1. Show some examples of programming assignment statement!
2. What is the operator for assign the value to the variable?

### Summary:

#### What is variable?

In computer programming, a variable is a storage location in memory that is used to hold a value. The value of a variable can be changed during the execution of a program.

Each variable has a name, which is used to refer to the variable in the code, and a data type, which determines the kind of value that the variable can hold.

There are several different data types in C++, including:

Integers: Integers are whole numbers that can be positive, negative, or zero. In C++, there are several different integer data types, including char, short, int, and long.

Floating-point numbers: Floating-point numbers are numbers with decimal points. In C++, the float and double data types are used to represent floating-point numbers.

Characters: Characters are single letters, digits, or symbols. In C++, the char data type is used to represent characters.

Booleans: Booleans are values that can either be true or false. In C++, the bool data type is used to represent booleans.

To use variables in C++, you will need to declare them and assign them values. Here is an example:

```cpp
int x;       // Declare an integer variable called x
x = 10;      // Assign the value 10 to x

char c;      // Declare a character variable called c
c = 'A';     // Assign the value 'A' to c

double d;    // Declare a double variable called d
d = 3.14;    // Assign the value 3.14 to d
```

#### Variable definition and initialization in C++

A variable definition means that the programmer writes some instructions to tell the compiler to create the storage in a memory location. The syntax for defining variables is:

```cpp
data_type variable_name;
```

Here `data_type` means the valid C++ data type which includes int, float, double, char, wchar\_t, bool and variable list is the lists of variable names to be declared which is separated by commas.  Variables are declared in the above example, but none of them has been assigned any value. Variables can be initialized, and the initial value can be assigned along with their declaration.

```cpp
data_type variable_name = value;
```

Examples:

```cpp
int value = 1234;       // whole numbers from -32768 .. 32767
char smalVal = 123;     // whole numbers from 0 .. 255
char letterA = 'A';     // character value like !"#0123..ABC..xyz
bool logicVal = true;   // 0 and 1 or false and true
float pi_value = 3.14;  // from -3.4E+38 .. +3.4E+38
char text[32] = "Some text.";
```

<!--
void setup() {
  Serial.begin(9600);
}

void loop() {
  Serial.println("VAR.NAME\tMEM.ADDR.\tVALUE");
  Serial.print("   value\t0x0");Serial.print((int)&value,HEX);Serial.print("\t");Serial.println(value);
  Serial.print(" smalVal\t0x0");Serial.print((int)&smalVal,HEX);Serial.print("\t");Serial.println(smalVal,DEC);
  Serial.print(" letterA\t0x0");Serial.print((int)&letterA,HEX);Serial.print("\t");Serial.println(letterA);
  Serial.print("logicVal\t0x0");Serial.print((int)&logicVal,HEX);Serial.print("\t");Serial.println(logicVal);
  Serial.print("pi_value\t0x0");Serial.print((int)&pi_value,HEX);Serial.print("\t");Serial.println(pi_value);
  Serial.print("    text\t0x0");Serial.print((int)&text,HEX);Serial.print("\t");Serial.println(text);
  delay(3000);
}
-->

In next [@fig:mem_addr] we can find previous variables stored in controllers' RAM memory (upper window of [@fig:mem_addr]). In the lover left corner of the [@fig:mem_addr] we can find printed memory addresses of these variables. In the memory table we can first notice `text` variable from the address `0x0100` within next 32 bytes (2 rows of the memory table). Next 4 bytes are occupied by `pi_value` variable, at the memory address `0x0124` `logicVal` is stored (1 byte), following with character letter A stored in variable named `letterA` at the address `0x0125` with the HEX value of `0x41`. At the memory address `0x0126` we can find `smalVal` variable which storing the value 123 (DEC) or `0x7B` in HEX. The last 2 bytes are occupied by the integer variable named `value` where the nuber 1234 is stored or in HEX 0x04 0xD2.


![Table of values stroed in RAM memory of Arduino UNO controller.](./slike/arduino_mem_address_2.png){#fig:mem_addr}

#### Measuring Time with programming loops
The easiest way to measure time is to simply count the number of loop\'s
executions. And if we know how long is one execution of the loop - we
can easily determine the time lapsed for the whole process.

Example:

```cpp
int t = 0;
while (t<10){
  t++;
  delay(100);
}
```

In the previous example the `while` loop is executed 10 times (t = \[0
.. 9\]), since each execution of the loop last 100 ms (determined by
`delay(100);`) the whole `while` loop last 1 s.

#### Time measuring with Timers

More proper way of measuring the time is by using the timer\'s values.
More on that can be read
[here](https://www.arduino.cc/reference/en/language/functions/time/millis/).  

Example:  


```cpp
unsigned long start_time;
unsigned long stop_time;
start_time = millis();
// time measured process goes here
// ...
stop_time = millis();
unsigned long duration = stop_time - start_time;
```

Where the `duration` is time measured in milliseconds.

#### Structures

n C++, a struct is a user-defined data type that groups together a collection of variables. It is similar to a class in that it can contain variables and functions, but there are a few key differences between the two.

One of the main differences between a struct and a class in C++ is that structs have public members by default, while classes have private members by default. This means that, by default, all members of a struct can be accessed directly from outside the struct, while members of a class can only be accessed through its member functions.

Another difference is that structs are often used for small, simple data structures that do not require the encapsulation and data hiding features provided by classes. Structs are commonly used for situations where you simply want to group together related data, such as representing a point in two-dimensional space, a date, or a color.

Here is an example of a simple struct in C++:

```cpp
struct Point {
    int x;
    int y;
};
```

This struct defines a new type called Point, which contains two variables of type int, x and y, representing the coordinates of a point in a two-dimensional space.

```cpp
Point p1;
p1.x = 3;
p1.y = 4;
```

In this example, we create a variable p1 of type Point and assign values to its members x and y.

It's also worth noting that C++ has also a keyword class which is semantically equivalent to struct except for the default access level of its members.

#### Enumeration

In C++, an `enum` (short for "enumeration") is a user-defined data type that consists of a set of named values. It is used to create a new type with a fixed set of possible values, which can make your code more readable and maintainable.

Here's an example of an enumeration that could be used in a mobile robot program to represent the different states of the robot:

```cpp
enum class RobotMoves{
    FORWARD,
    BACKWARD,
    MOVE_LEFT,
    MOVE_RIGHT,
    STOP
};
```
You can use this enumeration in the robot's control loop to check and update the current state of the robot:
```cpp
RobotMoves currentRobotState = RobotMoves::STOP;

while (true) {
    // Some other logic here
    // ...

    // Sampling the sensors based on the state of the robot
    switch (currentRobotState){
      case RobotMoves::FORWARD    : checkFrontSensors(); break;
      case RobotMoves::BACKWARD   : checkBackSensors(); break;
      case RobotMoves::MOVE_LEFT  : checkLeftSensors(); break;
      case RobotMoves::MOVE_RIGHT : checkRightSensors(); break;
      default: //nothing to do...
    }
}
```
This way, it's clear and easy to understand the current state of the robot, and it can also help to implement logic and different behaviors for each state.
It's also easy to add or remove states in the future if needed, without having to modify the code in many different places.

### Issues:

#### *<++>*

<++\>



 Conditional Statements
--------------------------------------------------------------------------------

Conditional statements in C++ are foundational constructs that allow programmers to execute specific sections of code based on certain conditions. These statements enable decision-making within a program, allowing it to respond differently to various inputs or situations. The most commonly used conditional statements in C++ are if, else if, and else.

Imagine you are programming a mobile robot that uses a bumper sensor to detect obstacles. The bumper sensor can return two states: 0 (no contact), 1 (contact with the obstacle). Based on the sensor's input, the robot should make decisions: stop moving forward when an obstacle is detected and adjust its path accordingly. This will be our future task in next chapter. First we have to construct robot's bumper with push button key and test it.

### Tasks:

1. Construct the bumper of the robot with push-button-switch as is shown in [this video instructions](https://www.youtube.com/watch?v=eWldNxh-q2c&t=11s).

2. And connect the push-button-switch (PBSW) terminals with module RobDuino according to [@tbl:SW-RobDuino]:

| PBSW con. | RobDuino connectors |
|:---------:|:-------------------:|
|   No. 1   |          A0         |
|   No. 2   |         GND         |
|   No. 3   |         +5V         |

Table: Connection of push-button-switch to the Robduino module. {#tbl:SW-RobDuino}

<iframe src="https://docs.google.com/presentation/d/19d-8UN3UQ1HTpq4a4PhSgt14YnIC8EE5Y1nDjwUab2Y/embed?authuser=0&hl=en&size=s" width="410" height="337" title="Conection of distance sensor" frameborder="0" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

3. Test the push-button-switch in the bumper with next [@lst:260_Conditional_Statements]:

```cpp
const int BUMPER_PIN          = A0;
const int TEST_BUMPER_LED_PIN = 3;
void setup()
{
  pinMode(BUMPER_PIN, INPUT);
  pinMode(TEST_BUMPER_LED_PIN, OUTPUT);
}

void loop()
{
  bool bumperIsPressed = digitalRead(BUMPER_PIN);
  if ( bumperIsPressed ) digitalWrite(TEST_BUMPER_LED_PIN, HIGH);
}
```
: Conditional Statements. {#lst:260_Conditional_Statements}

<!--
![Adding bumper to the robot.](./slike/BumperConstruction.png){#fig:bumper_construction}
-->

2. Then\... complete the program to turn OFF the LED when the bumper is not touching anything.
3. Next\... Change IF statements into single one IF-THEN-ELSE statement.
4. Complete the IF-statement with a block of code so that the LED will blink when the bumper is pressed.

### Questions:

1. Check if the LED on the output terminal D3 is ON when the bumper is pressed.
2. Measure the voltage potencial at the terminal A0 when the bumper is pressed.
3. Explain when the curly braces `{}` are necessary in the if-statement.

### Summary:

Conditional statements in C++ programming are utilized for flow control within a program. These statements allow the program to make decisions and execute certain blocks of code based on specified conditions. The primary conditional statements in C++ include `if`, `if-else`, nested `if-else-if`, and `switch-case`.

`If` executes a block of code if a specified condition is true.

`If-else` provides an alternate block of code if the initial condition is false.

Nested `if-else-if` involves multiple layers of if-else conditions within one another for complex decision making.

`Switch-case` allows a variable to be tested for equality against a list of values and executes the first match.

Thus, conditional statements provide essential control flow mechanisms in C++ programming.

#### IF, IF-ELSE, IF-ELSE-IF

can be written in several forms. The easiest one is:

```cpp
if (value_one) statement1;
```

In this case the variable named `value_one` can hold some numerical number. If `value_one` is `true` or greater than `0` the program will execute `statement1`.
But this simple example is not used so often due its simplicity. We rather use it in
this form:

```cpp
if ( value_one == value_two ){
  statement1;
  statement2;
}
```
In this case `value_one` can be any number and the `statement1` and `statement2` will be executed if the `value_one` will be equal to `value_two`. These command can be expanded into IF-ELSE form:
```cpp
if ( value_one == value_two ){
  statement1;
  statement2;
}else{
  statement3;
}
```

An else if ladder can be used to decide among multiple conditions.

```cpp
if (condition1) {
    // Code to execute if condition1 is true
} else if (condition2) {
    // Code to execute if condition2 is true
} else {
    // Code to execute if none of the above conditions is true
}
```

#### SWITCH statement

The switch statement allows you to execute one block of code out of many, based on the value of a variable. It's often more convenient than multiple if-else statements when dealing with variable values.

```cpp
int x = 2;

switch (x) {
  case 1: printf("x is 1"); break;
  case 2: printf("x is 2"); break;
  case 3: printf("x is 3"); break;
  default: printf("x is something else"); break;
}
```

In this example, the switch statement checks the value of x and executes the code block corresponding to the first case label that matches the value. The break statements are used to exit the switch statement once a match is found. If no match is found, the code block for the default label is executed.

#### Condition operators

Also other logical condition operators can be used:

- Less than: `a < b`
- Less than or equal to: `a <= b`
- Greater than: `a > b`
- Greater than or equal to: `a >= b`
- Equal to `a == b`
- Not Equal to: `a != b`

### Issues:

#### *<++>*

<++>



 Pointers and references
--------------------------------------------------------------------------------



 Classes and objects
--------------------------------------------------------------------------------


