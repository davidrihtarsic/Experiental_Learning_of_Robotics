---
parent: Basic Robotics
title: S-R-A LOOP
nav_order: 6
has_children: true
---

 SENSING REASONING ACTING LOOP
================================================================================


Robotics is a field of engineering that involves the design and operation of robotic systems. One of the most fundamental principles underlying robotic systems is the S-R-A (sensor-response-actuation) loop. This concept is at the heart of all robotic systems and is essential for understanding the behavior of robots.

The S-R-A loop involves a robot continually sensing its environment, interpreting the data, and then taking some action in response. In other words, the robot is constantly interpreting sensory input and responding with a motor action. It is a continuous cycle of sensing, reasoning, and acting.

The sensing component of the S-R-A loop generally involves the use of sensors such as cameras, ultrasound, or infrared sensors. These sensors detect the robot’s surroundings and provide the robot with the data necessary to make decisions. The response component of the loop involves the robot using its artificial intelligence to interpret the data and make decisions. This decision-making process is what gives robots the ability to respond to their environment.

The actuation component of the S-R-A loop is where the robot takes action. This action may involve a physical movement, such as walking, or it may involve activating a motor to perform a task, such as picking up an object.

The S-R-A loop is the basic building block of any robotic system. All robots use this concept as it is essential for a robot to be able to interact with its environment. Without it, robots would not be able to make decisions or take action. This concept is also important for enabling robots to learn, as it allows them to continually increase their knowledge and abilities.

Overall, the S-R-A loop is the cornerstone of robotics. It is essential for robots to be able to interact with their environment and learn from it. Without the S-R-A loop, robots would be unable to take any action or make decisions. It is an integral part of any robotic system.

From the S-R-A loop, lets start at the very beggining of the loop - at reading input signals by emphasizing the importance of received input signal. In other words, it is critical that the system be able to detect and interpret input signals in order to produce the appropriate responses. Once these input signals are received, they must be accurately processed and acted upon. This is the primary task of the S-R-A loop, and is the basis for any successful input processing system.

To read an input signal on an Arduino, you can use one of the digital input pins or one of the analog input pins. Digital input pins can only read two states: high (5 volts) or low (0 volts). They are often used to read switches or buttons, or to detect the presence or absence of a signal.

To read a digital input signal on an Arduino, you can use the digitalRead function, which takes a pin number as an argument and returns either HIGH or LOW. For example, to read the state of digital pin 2, you could use the following code:

```cpp
int pin = 2;
int state = digitalRead(pin);
```

Analog input pins, on the other hand, can read a range of voltage levels, from 0 to 5 volts. They are often used to read sensors that output an analog signal, such as a temperature sensor or a potentiometer.

To read an analog input signal on an Arduino, you can use the analogRead function, which takes a pin number as an argument and returns a value between 0 and 1023, corresponding to the voltage level on the pin. For example, to read the voltage on analog pin 0, you could use the following code:

```cpp
int pin = 0;
int value = analogRead(pin);
```

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: S-R-A Loop
nav_order: 4
---

## S-R-A loop

S-R-A loop is repeating process where:

1. Sensing,
2. Reasoning and
3. Acting

is involved during the procedure of controlling the robot. This is the most important part of software in robotics. Remember the `autonomous` control is `ability to perform intended tasks based on current state and sensing, without human intervention`.

The S-R-A loop is a common design pattern in robotics. It refers to the process of using sensors to gather information about the environment, processing the information to determine an appropriate response, and then executing the response using actuators.

Here is an pseudo example of how the S-R-A loop could be implemented in C++:

```cpp
while (true) {
  // 1. Sense the environment using sensors
  sensor_data = gatherSensorData();

  // 2. Process the sensor data to determine an appropriate response
  response = processSensorData(sensor_data);

  // 3. Execute the response using actuators
  executeResponse(response);
}
```

In this example, the `gatherSensorData` function is used to gather data from the robot's sensors, the `processSensorData` function is used to determine an appropriate response based on the sensor data, and the `executeResponse` function is used to execute the response using the robot's actuators. The loop is executed continuously, allowing the robot to constantly sense and respond to its environment.

### Tasks:

1. Using the S-R-A loop technique you should write the program in particular order:
    1.  Check the sensor. IF the bumper \...
    2.  \... Is pressed the robot has to stop/go back/turn.
    3.  \... Is not pressed the robot can drive forward.

    Test the [@lst:270_SRA_Loop] and **find out why the robot does not stop.** (Such mistake is quite often - can you fix it):

```cpp
#include <RobotMovingFunctions.h>
const int BUMPER_PIN = A0;
void setup()
{
  setIOpins();
  pinMode(BUMPER_PIN, INPUT);

  bool bumperIsPressed = digitalRead(BUMPER_PIN);
  if ( bumperIsPressed )
  {
    stopTheRobot();
  }
  else
  {
    moveForward();
  }
}
void loop()
{
}
```
: SRA Loop. {#lst:270_SRA_Loop}

2. Hint for fixing the [@lst:270_SRA_Loop]: _S-R-A must be a loop function!_
3. Write a program to drive the robot around the class and avoid the obstacles.
4. Make split bumper design (left and right) as presented in [@fig:rob_50] and write a program so that the robot avoids the obstacle depending on which side the obstacle is present.

![Split bumper design allowing detecting obstacles from left and right.](./slike/rob_50.png){#fig:rob_50 width=8cm}

### Questions:

1. What for `S-A-R loop` stands for?
2. Mark all three basic S-A-R processes in previous code example.
3. Can the `line 8` of the [@lst:270_SRA_Loop] be written outside of `loop()` function? What would happened if so?

### Summary:

#### <++>

<++>

### Issues:

#### *<++>*

<++>  

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Digital Input
nav_order: 4
---

## Digital input

Digital inputs can only measure 2 different values. As such they are binary inputs and it's values are represented as logical `0` and `1` or in other words `false` and `true` or `LOW` and `HIGH`. However from electrical point of view those values are basically different voltage potencials. Usually potencial `0 V` is presented as logical `0` and potencial `+5 V` is indicated as logical `1`. Digital inputs are often used for detecting state of switches, board keys and push buttons...

Lets go back to fundamentals of digital inputs and explore some options we have to connect a push-button-switch.

![Different options of wireing the bush-button-switch.](./slike/PBSw_All.png){#fig:PBSw_All}

### Tasks:

1. Connect the push-button-switch according to first diagram on [@fig:PBSw_All] and test the program [@lst:280_Digital_Input]

```cpp
const int BUMPER_PIN = A0;
void setup()
{
  pinMode(BUMPER_PIN, INPUT);
}

void loop()
{
  bool bumperIsPressed = digitalRead(BUMPER_PIN);
  if ( bumperIsPressed ) digitalWrite(3, HIGH);else digitalWrite(3, LOW);
}
```
: Digital Input. {#lst:280_Digital_Input}

2. Try to connect the bush-button-switch according to second diagran on [@fig:PBSw_All]

| PBSW con. | RobDuino connectors |
|:---------:|:-------------------:|
|   No. 1   |          A0         |
|   No. 2   |    not connected    |
|   No. 3   |         +5V         |

Table: Connection of push-button-switch with only 2 terminals. {#tbl:sw_two_pins}

Try to understand why this setup is not working. And test all other options in [@fig:PBSw_All]

3. Solve the problem by constructing a `voltage divider` with `pull-down` resistor (third diagran on [@fig:PBSw_All]).
4. Try to understand how the voltage potencial is spread among the components in electrical loop and how we can calculate this by using 2nd Kirchhoff's Rule.
5. Change the setup of PBSW and resistor to a `pull-up` setup (fourth diagran on [@fig:PBSw_All]). What is changed?
6. Enable internal `pull-up` resistor (and remove external one - fifth diagran on [@fig:PBSw_All]).

### Questions:

1. Measure the voltage potencial on pin A0 where the bumper is in ether position.
2. Why the setup is not working properly if we connect the PBSW only to +5V voltage potencial?
3. Draw a schematic circuit of the bush-button-switch connected to controller.
4. What is determined by 2nd Kirshhoff's Rule?
5. How can we enable `pull-up` resistor?

### Summary:
#### 2nd Kirshhoff's Rule
Kirchhoffs Voltage Rule states that `in any closed loop network, the total voltage around the loop is equal to the sum of all the voltage drops within the same loop` which is also equal to zero. In other words the algebraic sum of all voltages within the loop must be equal to zero. This idea by Kirchhoff is known as the Conservation of Energy.

### Issues:
#### *<++>*
<++>

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Pull-Up Resistor
nav_order: 4
---

## Pull-up resistors on digital input

On the module RobDuino we can find two "on-board push button switches". Wiring of this switches is presented in [@fig:RobDuino_OnBoardPwshButtonSwitch_s1], where can we noticed that both switches are connected to ground voltage potential.

![Wiring of on-board switches.](./slike/RobDuino_OnBoardPwshButtonSwitch_s1.png){#fig:RobDuino_OnBoardPwshButtonSwitch_s1}

To properly use this on-board push-button switches we must enable the `pull-up` resistors of A4 and A5 input of microcontroller.

### Tasks:

1. Configure pins `A4` and `A5` as inputs with `pull-up` resistor.
2. At the end of the `setup()` function add the `while-loop` which will delay the execution of the program until we press the `A4` key - acting as a "START BUTTON".
3. Use the `A5` key to stop the robot and terminate the execution of the program.

```cpp
#include <RobotMovingFunctions.h>
const int KEY_A4 = A4;
const int KEY_A5 = A5;

void setup()
{
  setIOpins();
  pinMode(KEY_A4, INPUT_PULLUP);
  // KEY_A5 setup here...
}

void loop()
{
  moveForward();
  //to-do: the key reading
  bool stopTheRobotKey = 0;
  if (stopTheRobotKey == 1)
  {
    stopTheRobot();
    exit(0);        //terminate the program
  }
}
```
: Pull Up Resistors on Digital Input. {#lst:290_Pull_Up_Resistors_on_Digital_Input}

### Questions:

1. What is the programming instruction of reading the value form digital input?
2. Which values can be assigned to `bool` type variable?
3. Explain the programming instruction `exit(0)`.

### Summary:

#### <++>

<++>

### Issues:

#### *<++>*

<++>


---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: PWM as Input sig.
nav_order: 4
---

## Pulse width as digital input

Digital input can also be used to transferee other data. One way is to modulate the data into pulse duration e.g. longer the duration of the pulse, bigger the value. This modulation of data is called **Pulse-width modulatio** or **PWM**. Such an example is ultrasonic distance sensor. Where the distance is hidden in the time duration that sound needed of travel the distance from source to object and back as presented in [@fig:UltraSound_sen_50].

![How Ultrasonic sensor works.](./slike/UltraSound_sen_50.png){#fig:UltraSound_sen_50}

Since the speed of sound in air is constant ($v_s = 340 m/s$) we can easily calculate the distance according to [@eq:calc_dist].

$$ distance = \frac{1}{2} v_s t_{duration} $${#eq:calc_dist}

<!--
datasheet on ultrasonic sensor HC-SR04
https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf
-->

### Tasks:

1. Connect the ultrasonic distance sensor to module Robduino according to [@tbl:con_ultrason]

| HC-SR04 pins | RobDuino pins |
|:------------:|:-------------:|
|      +5V     |      +5V      |
|    Trigg.    |       A0      |
|     Echo     |       A1      |
|      GND     |      GND      |

Table: Connestion of ultrasonic distance sensor. {#tbl:con_ultrason}

2. Test next program if you get reasonable data of time duration in `Serial` window.

```cpp
const char TRIGGER_PIN  = A0;
const char ECHO_PIN     = A1;

void setup()
{
  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  Serial.begin(9600);
}

int getPulseWidth_us()
{
  digitalWrite(TRIGGER_PIN,HIGH);
  delayMicroseconds(10); 
  digitalWrite(TRIGGER_PIN,LOW);
  return pulseIn(ECHO_PIN, HIGH);
}

float getDistance_cm()
{
  // do distance calculation here...
  return 0
}
void loop()
{
  float distance_cm = getDistance_cm();
  int duration_us = getPulseWidth_us();
  Serial.println(duration_us);
  delay(2000);
}
```
: PWM as Digital Input. {#lst:300_PWM_as_Digital_Input}

3. Add needed code in function `getDistance_cm()` to calculate the distance in cm. Also change the `Serial.println(duration_us)` program line to output `distance_cm` value.

### Questions:

1. What is PWM?
2. How are PWM data presented in digital signal?
3. What voltage is used to transmit PWM values?

### Summary:
#### <++>

### Issues:
#### <++>


---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Analog Input
nav_order: 4
---

## Analog input

In general, controllers are equipped with `Analog to Digital Converters` or short `ADC`. This internal devices converts voltage potencial into numeric value which can be further used by written program. This is also the case in Arduino UNO converter by the function `analogRead(pin_number)`. In this case the voltage range $[0.0\ V .. +5.0\ V]$ is converted in to range of numbers $[0 .. 1024]$.

### Tasks:

1. Unmount robot's bumper and all connections to the switch.
2. Equip the robot with distance sensor according to [video](https://www.youtube.com/embed/ELYsyuhbQfY) and scheme (see [@fig:distance_sen]).

![Mounting possition of analog distance sensor.](https://img.youtube.com/vi/ELYsyuhbQfY/maxresdefault.jpg){#fig:distance_sen}

3. Try next [@lst:310_Analog_Input] and check the output of distance sensor in Serial monitor.

```cpp
const int DIST_SEN_PIN = A0;
void setup()
{
  pinMode(DIST_SEN_PIN, INPUT);
  Serial.begin(9600);
}

void loop()
{
  int adc_value = analogRead(DIST_SEN_PIN);
  Serial.println(adc_value);
  delay(1000);
}
```
: Analog Input. {#lst:310_Analog_Input}

4. Convert the `analog_sensor_value` into `input_voltage` and measure the input voltage potencial with volt-meter. The formula for conversion can be programmed as:

```cpp
float input_voltage = 5.0/1024 * adc_value;
```

5. From the [datasheet](https://www.farnell.com/datasheets/1657845.pdf) for the distance sensor try to code the function for measuring the distance in cm. According to documentation there is almost linear trend between output voltage and $distance^{-1}$. Thus we can get good result with [@eq:calc_disd].

    $$ distance^{-1}[cm] = 0.045 V_{out} $${#eq:calc_disd}

    Next example can be your guide to code the function.

```cpp
float getDistance_cm()
{
  int adc_value = analogRead(DIST_SEN_PIN);
  float input_voltage = 5.0/1024 * adc_value;
  float distance = 1/(0.045 * input_voltage);
  return distance;
}
```

### Questions:

1. What kind of values do you getting from the reading of the distance sensor with the function `analogRead(A0)`?
2. Find the reasonable value where you should stop the robot.
3. Measure the voltage potencial of the sensor's output.


<iframe width="410" height="337" frameborder="0" src="https://www.youtube.com/embed/ELYsyuhbQfY"></iframe>

<iframe src="https://docs.google.com/presentation/d/1j4yvBeTajgG9wFb5mw9SUPUTLXjPWNWjOnINUEmyAx8/embed?authuser=0&hl=en&size=s" width="410" height="337" title="Conection of distance sensor" frameborder="0" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

### Summary:

#### Analog to digital converter - ADC

ADC is an electronic sistem that converts analog signal (voltage) to a
digitalized values. In our particular case the range of an analog
voltage from 0V to 5V is converted to range of numbers from 0 to 1024.

### Issues:

#### *<++>*

<++>  

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Detecting Obstacles
nav_order: 4
---

## Avoiding obstacles

### Tasks:

Write the program to drive the robot around the class and avoid the
obstacles.

1.  Check the value of distance sensor. If the distance is greater than ...
2.  \... the robot can drive forward.
3.  \...else \... the robot must to stop/go back/turn.

```cpp
#include <RobotMovingFunctions.h>
const int DIST_SEN_PIN   = A0;
const int DISTANCE_LIMIT = 20;
void setup()
{
  setIOpins();
  pinMode(DIST_SEN_PIN,INPUT);
}
float getDistance_cm()
{
  int adc_value  = analogRead(DIST_SEN_PIN);
  float distance = 1/(0.045 * 5.0/1024 * adc_value);
  return distance;
}
void loop()
{
  if ( getDistance_cm() > DISTANCE_LIMIT )
  {
    moveForward();
  }
  else
  {
    stopTheRobot();
  }
}
```
: Avoiding Obstacles. {#lst:320_Avoiding_Obstacles}

### Questions:

1. What are the values of the distance sensor (use `Serial.println(distance)` to verify)?
2. Robot stil hits the obstacles that are not in view angle of the distance sensor. Write and use new function for moving the robot forward more carefully.

### Summary:

#### Moving the robot and checking the sensor simultaneously
The main important proces in robotics is S-R-A loop. This process is used in different situations and many times. One can be where we are moving the robot forward and at the same time observing the sensors value with the intention to stop it when the specific condition is met.

```cpp
void goForwardCarefully()
{
   for (int i = 0; i < 10; i++)
   {
      robotLeft();delay(50);
      if (getDistance_cm() < DISTANCE_LIMIT) brake;
   }
   
   for (int i = 0; i < 10; i++)
   {
      robotRight();delay(50);
      if (getDistance_cm() < DISTANCE_LIMIT) brake;
   }
}
```

<++>

### Issues:

#### *<++>*

<++>

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Ligth Sensor
nav_order: 4
---

## Light sensor

### Tasks:
1. To construct a light sensor using a voltage divider configuration with a phototransistor and a resistor (with a value in the hundreds of kilohms range), you would set it up as follows:

    1. Components:
        - Phototransistor: This acts as a variable resistor whose resistance changes based on the amount of light it receives. The more light that hits the phototransistor, the lower its resistance.
        - Fixed Resistor: This is a resistor with a high resistance value, typically in the range of several hundred kilohms, to form the other half of the voltage divider.
    2. Configuration:
        - Connect one end of the phototransistor to the positive voltage supply (Vcc).
        - Connect the other end of the phototransistor to one end of the fixed resistor.
        - Connect the other end of the fixed resistor to the ground.
    More detailed construction of light sensor is show on [video](https://www.youtube.com/embed/wEN1e6m1FGY) and scheme. 

2. Add also the light bulb which will help to lightning the area beneath the robot.

![Mounting a light sensor.](https://img.youtube.com/vi/wEN1e6m1FGY/maxresdefault.jpg)

1. To test the light sensor and light bulb test this example code and check the reported serial data.

```cpp
const int LIGHT_SENSOR_PIN = A0;

void setup()
{
  pinMode(LIGHT_SENSOR_PIN , INPUT);
  Serial.begin(9600);
}

void loop()
{
  int light_sensor_value = analogRead(LIGHT_SENSOR_PIN );
  Serial.println(light_sensor_value );
  delay(200);
}
```
: Ligth Sensor. {#lst:330_Ligth_Sensor}

2. Try different resistors (1k, 10k, 100k, 1M) and find out at which the sensitivity of the sensor is greatest.

| Resistance | (black) Sensor value | (whithe) Sensor value | Sensor difference |
|-----------:|:--------------------:|-----------------------|-------------------|
|     1 kOhm |                      |                       |                   |
|    10 kOhm |                      |                       |                   |
|   100 kOhm |                      |                       |                   |
|     1 MOhm |                      |                       |                   |

Table: Testing the sensitivity of the light sensor. {#tbl:sensor_sensitivity}

### Questions:

1.  What is the value of the sensor when the robot is over white/black area?
    - ADC value on white:
    - ADC value on black:
2.  Calculate the average between those two values.
    - Average is:

<iframe width="410" height="337" frameborder="0" src="https://www.youtube.com/embed/wEN1e6m1FGY"></iframe>

<iframe src="https://docs.google.com/presentation/d/1nVl7aVy0qCZ7b6E-bIywXlQZ7PH8LOBB2sb2VxsBKR0/embed?authuser=0&hl=en&size=s" width="410" height="337" title="Constructing the light sensor" frameborder="0" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

### Summary:

#### Sensors

Sensors are electronic devices which convert physical quantity into
electrical quantity (usually voltage). In simplest setup, sensor can be
constructed as voltage divider with two resistors - $R_1$ and $R_2$. One of
the resistors is resistor with fixed resistance value (eg. $R_1=10k\Omega$).
The second one is a bit special and it\'s resistance depends on some
physical quantity (e.g. light, temperature, humidity\...). When
combining those two resistors into such voltage divider the output of
the voltage divider can be calculated as: 

$$ U_{Out} = \frac{R_1}{R_1 + R_2} U_0 $$

#### Voltage Divider Principle

The junction between the phototransistor and the fixed resistor is where the output voltage (Vout) is measured.
As the light intensity increases, the resistance of the phototransistor decreases. This causes the voltage across the fixed resistor to increase (because a smaller portion of the total voltage is dropped across the phototransistor).
Conversely, when the light intensity decreases, the resistance of the phototransistor increases, causing more voltage to drop across it, and less across the fixed resistor, thus lowering Vout.

### Issues:

#### *Value of the sensor is very small*  
If the value of the sensor is less than 100 the resistance of $R_2$ (connected to GND) is to low in comparismant to the resistance of R_1 (connected to +5V).

#### *Value of the sensor is large*  
If the value of the sensor is grater than 900 the resistance of $R_2$ (connected to GND) is to hi in comparismant to the resistance of R_1 (connected to +5V).

#### How to increase the sensors' response?
To increase the response of a light sensor built using a phototransistor and a resistor in a voltage divider configuration, you can try the following strategies:

- Fine-Tuning: Experiment with different resistor values to find the optimal balance between sensitivity and the operating range that suits your application. In general, sensors' response will be the biggest when the output voltage will change across $V_c/2$.
- Optimize Phototransistor Orientation and Placement:
    Ensure the phototransistor is optimally placed to receive the maximum amount of light from the light source. Avoid orientations where the phototransistor could be shaded or receive reflected light, which might decrease accuracy.

- Filter and Shield from Interference:

    - Use optical filters to limit the light spectrum that reaches the phototransistor, focusing on the wavelengths of interest. This can help in applications where specific types of light need to be detected.
    - Shield the sensor from ambient light or other light sources that might cause interference, ensuring that only light from the target source impacts the sensor's readings.

---
grand_parent: Basic Robotics
parent: S-R-A LOOP
title: Line Follower
nav_order: 4
---

## Line follower

### Tasks:

1. Write the program to control the robot follow the line ( actually above the edge between black and white area ). Some programming hints you can find in [@lst:340_Line_Follower] :

```cpp
#include <RobotMovingFunctions.h>
const int LIGHT_SENSOR_PIN = A0;
const int SURFACE_BRIGHTNESS_REFERENCE = 400;

void setup()
{
  setIOpins();
  pinMode(LIGHT_SENSOR_PIN , INPUT);
}

void loop()
{
  int light_sensor_value = analogRead(LIGHT_SENSOR_PIN );
  if ( light_sensor_value < treshold_value )
  {
    // do this if robot is over the black line
  }
  else
  {
    // do this if robot is over white area
  }
}
```
: Line Follower. {#lst:340_Line_Follower}

### Questions:

1.  What is the program function to get the `light_sensor_value`?
2.  Determine the movements of the robot if the robot is over the black
    area and if the robot is over the white area.

### Summary:

#### <++>

<++>

### Issues:

#### *<++>*

<++>

