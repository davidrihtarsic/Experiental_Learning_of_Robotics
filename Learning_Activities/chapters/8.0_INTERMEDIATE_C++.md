---
published: false
---

 INTERMEDIATE C++
================================================================================

Welcome to Intermediate C++ programming! This course will dive deeper into the core aspects of C++ programming and provide you with a solid foundation for further development. We're going to cover some of the building blocks of C++, including arrays, strings, pointers, classes and objects, exception handlers, and much more.

Firstly, we'll explore arrays, which allow you to store multiple values of the same type in a single block of memory. This can be particularly useful when programming a mobile robot to follow a specified path, for example:

```c++
int path[5] = {1, 2, 3, 4, 5};
```

Next, we'll dissect strings – sequences of characters used to store and manipulate text. For instance, we may use a string to denote the robot's status:

```c++
std::string status = "Moving Forward";
```

Pointers are on our list as well. They are essential and powerful features in C++, storing memory addresses of other variables, which can be useful for dynamic memory allocation in robot's tasks:

```c++
int batteryLevel = 100;
int* p = &batteryLevel;
```

We will also delve into classes and objects – the backbone of Object-Oriented Programming (OOP). Classes act as blueprints for objects, while objects represent instances of a class. For mobile robot programming, we could have a class \"Robot\" and create objects representing specific robots:

```c++
class Robot {
 std::string name;
 int speed;
 // Other attributes and methods...
};

Robot MobileRobot;
MobileRobot.speed = 255; //full speed
```

Lastly, we'll look into exception handlers, they are mechanisms that handle runtime errors, ensuring our robot doesn’t crash when it encounters an issue:

```c++
try {
 // Code that could throw an exception
} catch (const std::exception& e) {
 // Handle exception
}
```

By the end of this course, you'll have a solid understanding of these key C++ programming concepts and be able to apply them to real-world mobile robot programming scenarios. So, let's get started!



 Arrays and strings
--------------------------------------------------------------------------------



 Pointers and references
--------------------------------------------------------------------------------



 Classes and objects
--------------------------------------------------------------------------------



 Exception handling
--------------------------------------------------------------------------------



 Input and output
--------------------------------------------------------------------------------



 Debugging and testing
--------------------------------------------------------------------------------



 Advanced topics threading memory management templates
--------------------------------------------------------------------------------

### Bit-field variable type

Variable bit fields are a specific type of data structure in C++ that allows a user to store multiple bit-sized values within a single variable. This can be useful for storing several different values in the same memory space or for compressing data. An example of a variable bit field in C++ is shown below:

```c++
struct example {
 unsigned int value1 : 4; // Use 4 bits
 unsigned int value2 : 8; // Use 8 bits
 unsigned int value3 : 12; // Use 12 bits
} myStruct;
```

In this example, we have defined a structure called 'example' which contains three members - 'value1', 'value2', and 'value3'. Each of these members has been defined as a variable bit field using the 'unsigned int' data type and the ':' syntax, which allows us to specify the number of bits that each member should use. In this case, 'value1' will use 4 bits, 'value2' will use 8 bits, and 'value3' will use 12 bits. To access these values, we can use the members of the structure, for example, 'myStruct.value2'.

```c++
struct adc4 {
  unsigned int value1 : 10;
  unsigned int value2 : 10;
  unsigned int value3 : 10;
  unsigned int value4 : 10;
};

unsigned int adc_val[40];           //40 values
adc4 myAdc[10];                     //40 values

void setup() {
  Serial.begin(9600);
  Serial.println(sizeof(adc_val));  //print 80
  Serial.println(sizeof(myAdc));    //print 50
}

void loop() {

}
```

